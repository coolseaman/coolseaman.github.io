<!DOCTYPE html><html lang="Zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script>(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4528ef8fec41aa4331cbdf867fe84204";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
})();
</script><title> 基础算法 · HY</title><meta name="description" content="基础算法 - Coolseaman"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://coolseaman.github.io/atom.xml" title="HY"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/coolseaman" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">基础算法</h1><div class="post-info">2019年2月22日</div><div class="post-content"><blockquote>
<p>最近打算学习一些算法，这里先对一些基础算法只是进行重温，对算法的知识点进行一些总结，毕竟有文字输出效果会更好。</p>
</blockquote>
<a id="more"></a>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归是一种非常优雅的解决问题的方式。它可以把复杂的问题逐步分解成简单的问题，逐步得到结果。<br>递归就是在函数中，满足递归条件，就调用函数自身，直到满足基线条件，递归返回。<br>每个递归函数都有两部分：</p>
<ul>
<li>基线条件：函数不再调用自己，避免形成无限循环。</li>
<li>递归条件：函数调用自己。</li>
</ul>
<p><strong>栈</strong><br>栈是计算机中一种非常常见的数据结构，可以进行数据的压入（插入）和弹出（删除并读取）。</p>
<p><strong>调用栈</strong><br>当函数调用时，计算机首先会为该函数调用分配一块内存，存储函数调用设计的所有变量值。当函数内部调用其他函数时，计算机就会为内部调用函数也分配一块内存，第二块内存位于第一块内存的上面，当函数调用返回，第二块内存就会从栈顶弹出。这就被称为调用栈。</p>
<p><strong>递归调用栈</strong><br>递归调用栈中包含所有未完成的函数调用。在递归中，在最终返回结果前，每个函数都还未完成，所以栈中会存储每个调用函数的信息，每个函数调用都要占用一定的内存。所以如果栈很高，就会占用非常多的内存资源。解决方法如下：</p>
<ul>
<li>重新编写代码，使用循环。</li>
<li>使用尾递归，这个貌似比较高级，待深究。</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>这里要用到一种分而治之的思想（divide and conquer, D&amp;C），即递归式问题解决方法。</p>
<p><strong>D&amp;C原理</strong></p>
<p>D&amp;C的工作原理：</p>
<ul>
<li>找出简单的基线条件；</li>
<li>确定如何缩小问题的规模，使其符合基线条件。</li>
</ul>
<p>这里有一个好玩的问题：</p>
<blockquote>
<p>假设你是一个农场主，有一块168*64的土地。<br>现在要你均匀分成正方形土地，且分的方块要尽可能大，你会怎样分？</p>
</blockquote>
<p>这里涉及到一个欧几里得算法的问题：又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。</p>
<p>我们可以先从这块地中划出两个最大的方块，然后对剩下的一小块地再次划出最大的方块，就这样递归，直到没有剩下地块为止。这样我们就使用的递归的方式来解决问题。</p>
<p><strong>快速排序</strong></p>
<p>工作原理：</p>
<ul>
<li>从数组中选择一个元素，这个元素成为基准值（pivot）；</li>
<li>找出比基准值小的元素以及比基准值大的元素，这被称为分区。分区后得到一个由所有小于基准值的数组成的子数组，一个由所有大于基准值的数组成的子数组，两个子数组是无序的；</li>
<li>然后对两个子数组进行快速排序。</li>
</ul>
<p>下面是快速排序的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def quicksort(array):</div><div class="line">    if len(array) &lt; 2:</div><div class="line">        return array</div><div class="line">    else:</div><div class="line">        pivot = array[0]</div><div class="line">        less = [i for i in array[1:] if i &lt;= pivot]</div><div class="line">        greater = [i for i in array[1:] if i &gt; pivot]</div><div class="line">        </div><div class="line">        return quicksort(less) + [pivot] + quicksort(greater)</div><div class="line">    </div><div class="line">print quicksort([10,5,2,3])</div></pre></td></tr></table></figure>
<p>时间复杂度<br>快速排序的性能高度依赖你选择的基准值。</p>
<ul>
<li>最糟情况：始终选择第一个值作为基准值，则调用栈的高度为n；</li>
<li>最佳情况：始终将中间值作为基准值，则调用栈的高度为log n。</li>
</ul>
<p>因为每层栈需要的时间为O(n)，所以时间复杂度方面：</p>
<ul>
<li>最佳情况：O(n) * O(log n) = O(n log n)</li>
<li>最糟情况：O(n) * O(n) = O(n2)</li>
</ul>
<p>最佳情况也是平均情况，只要每次都随机选择一个数组元素作为基准值，快速排序的平均运行时间将为O(n log n)。快速排序是最快的排序算法质疑，也是D&amp;C典范。</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表我们非常熟悉，在Python中就是字典，在JavaScript中就是对象，等。每一种语言中都有自己对于散列表的实现。这里简单总结一下散列表的实现原理。</p>
<p>散列表平均情况下的时间复杂度是个常量：O(1)</p>
<p><strong>实现原理</strong>：<br>    将输入通过散列函数输出一个数组的索引，在数组的该索引位置上存储一个值，这样就可以快速得出我们想要的结果。</p>
<p><strong>避免冲突</strong>：<br>不够理想的散列函数可能会将不同的键映射到数组的同一个位置，这样就需要在这个位置上存储一个链表，就会导致性能下降。</p>
<p>要提升散列表的性能，需要：</p>
<ul>
<li>较低的装填因子；</li>
<li>良好的散列函数。</li>
</ul>
<p>装填因子就是 <code>散列表包含的元素数/数组位置总数</code>。所以装填因子越小，冲突的可能性就越小，装填因子过大，我们可以调整数组长度，通常将数组增加一倍。一个不错的经验规则是：一旦装填因子大于0.7，就调整散列表的长度。</p>
<p>良好的散列函数可以让数组中的值呈均匀分布。</p>
<h2 id="广度优先搜索（宽度优先搜索）"><a href="#广度优先搜索（宽度优先搜索）" class="headerlink" title="广度优先搜索（宽度优先搜索）"></a>广度优先搜索（宽度优先搜索）</h2><p><strong>什么是图？</strong><br>图由节点和边组成，一个节点可能和众多节点相连接，这些节点称为邻居。</p>
<p>广度优先搜索是一种用于图的查找算法，帮助回答两个问题：</p>
<ul>
<li>从节点A出发，有前往节点B的路径吗？</li>
<li>从节点A出发，前往节点B的哪条路径最短？</li>
</ul>
<p>广度优先搜索的基本思路就是现在一级节点中搜索，如果找到目标，则完成，如果没有找到目标，继续在二级节点中搜索，依次是三级、四级…直到返回搜索结果。</p>
<p>在检查的过程中要按照添加顺序进行，所以我们要用到队列。队列是一种先进先出（FIFO）的数据结构，而栈是一种后进先出（LIFO）的数据结构。</p>
<p>关于图的代码实现，我们可以使用散列表来实现，例如下图：<br><img src="../../../../img/%E5%9B%BE.png" alt="img"></p>
<p>我们可以用如下代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">graph = &#123;&#125; </div><div class="line">graph[&quot;you&quot;] = [&quot;alice&quot;, &quot;bob&quot;, &quot;claire&quot;] </div><div class="line">graph[&quot;bob&quot;] = [&quot;anuj&quot;, &quot;peggy&quot;]</div><div class="line">graph[&quot;alice&quot;] = [&quot;peggy&quot;]</div><div class="line">graph[&quot;claire&quot;] = [&quot;thom&quot;, &quot;jonny&quot;] </div><div class="line">graph[&quot;anuj&quot;] = [] </div><div class="line">graph[&quot;peggy&quot;] = [] </div><div class="line">graph[&quot;thom&quot;] = [] </div><div class="line">graph[&quot;jonny&quot;] = []</div></pre></td></tr></table></figure></p>
<p>算法实现原理：<br><img src="../../../../img/%E5%8E%9F%E7%90%86.png" alt="img"></p>
<p>算法代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">from collections import deque</div><div class="line"></div><div class="line">def search(name):</div><div class="line">    search_queue = deque()</div><div class="line">    search_queue += graph[name]</div><div class="line">    searched = [] //用于记录检查过的人</div><div class="line">    </div><div class="line">    while search_queue:</div><div class="line">        person = search_queue.popleft()</div><div class="line">        if person not in searched:</div><div class="line">            if person_is_seller(person):</div><div class="line">                print person + &apos;is seller&apos;</div><div class="line">                return True</div><div class="line">            else: </div><div class="line">                search_queue += graph[person]</div><div class="line">        searched.append(person)</div><div class="line">        </div><div class="line">    return False</div><div class="line"></div><div class="line">def person_is_seller(name):</div><div class="line">    //随意定义一个判断函数</div><div class="line">    return name[-1] == &apos;m&apos;</div><div class="line">    </div><div class="line">search(&apos;you&apos;)</div></pre></td></tr></table></figure></p>
<p><strong>小结</strong></p>
<ul>
<li>面对寻找最短路径的问题，可以先用图来建立模型，再使用广度优先搜索来解决问题。</li>
<li>有向图中的边有箭头，箭头的方向指定了关系的方向。</li>
<li>无向图中的边没有箭头，其中的关系是双向的。</li>
<li>你需要按照加入顺序进行检查，否则找到的可能就不是最短路径，因此搜索列表必须是队列。</li>
<li>对于检查过的人务必不要再去检查，否则可能导致无限循环，例如一个无向图。</li>
</ul>
<h2 id="狄克斯特拉算法（Dijkstra）"><a href="#狄克斯特拉算法（Dijkstra）" class="headerlink" title="狄克斯特拉算法（Dijkstra）"></a>狄克斯特拉算法（Dijkstra）</h2><p>前一章中使用广度优先搜索来查找两点之间的最短路径，那是的最短路径的意思是段数最少。在狄克斯特拉算法中，给每段都分配了数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。</p>
<blockquote>
<p>狄克斯特拉算法只适用于有向无环图。<br>狄克斯特拉算法不能用于包括负权边的图。</p>
</blockquote>
<p><strong>实现</strong><br>我们以下图中的例子来进行实现：<br><img src="../../../../img/dijkstra.png" alt="img"></p>
<p>首先，我们需要定义三个散列表来记录图的相关信息。<br>graph:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// graph用来记录图的信息，包括节点的邻居和前往邻居的开销</div><div class="line">graph = &#123;&#125;</div><div class="line"></div><div class="line">graph[&apos;start&apos;] = &#123;&#125;</div><div class="line">graph[&apos;start&apos;][&apos;a&apos;] = 6</div><div class="line">graph[&apos;start&apos;][&apos;b&apos;] = 2</div><div class="line"></div><div class="line">graph[&apos;a&apos;] = &#123;&#125;</div><div class="line">graph[&apos;a&apos;][&apos;fin&apos;] = 1</div><div class="line"></div><div class="line">graph[&apos;b&apos;] = &#123;&#125;</div><div class="line">graph[&apos;b&apos;][&apos;a&apos;] = 3</div><div class="line">graph[&apos;b&apos;][&apos;fin&apos;] = 5</div><div class="line"></div><div class="line">graph[&apos;fin&apos;] = &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>costs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//costs用于存储每个节点的开销</div><div class="line">infinity = float(&apos;inf&apos;)</div><div class="line">costs = &#123;&#125;</div><div class="line">costs[&apos;a&apos;] = 6</div><div class="line">costs[&apos;b&apos;] = 2</div><div class="line">costs[&apos;fin&apos;] = infinity</div></pre></td></tr></table></figure></p>
<p>parents:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// parents用于存储父节点</div><div class="line">parents = &#123;&#125;</div><div class="line">parents[&apos;a&apos;] = &apos;start&apos;</div><div class="line">parents[&apos;b&apos;] = &apos;start&apos;</div><div class="line">parents[&apos;fin&apos;] = None</div></pre></td></tr></table></figure></p>
<p>还需要一个数组用于存储已处理过的节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">processed = []</div></pre></td></tr></table></figure></p>
<p>完成了各种数据结构的创建，接下来我们开始算法。<br><img src="../../../../img/dijkstra1.png" alt="img"><br>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 未处理的节点中找到开销最小的节点</div><div class="line">node = find_lowest_cost_node(costs)</div><div class="line"></div><div class="line">while node is not None:</div><div class="line">    cost = costs[node]</div><div class="line">    neighbors = graph[node]</div><div class="line">    for n in neighbors.keys():</div><div class="line">        new_cost = cost + neighbors[n]</div><div class="line">        if costs[n] &gt; new_cost:</div><div class="line">            costs[n] = new_cost</div><div class="line">            parents[n] = node</div><div class="line">        </div><div class="line">    processed.append(node)</div><div class="line"></div><div class="line"></div><div class="line">def find_lowest_cost_node(costs): </div><div class="line">    lowest_cost = float(&apos;inf&apos;)</div><div class="line">    lowest_cost_node = None</div><div class="line">    </div><div class="line">    for node in costs:</div><div class="line">        cost = cost[node]</div><div class="line">        if cost &lt; lowest_cost and node not in processed:</div><div class="line">            lowest_cost = cost</div><div class="line">            lowest_cost_node = node </div><div class="line">    </div><div class="line">    return lowest_cost_node</div></pre></td></tr></table></figure></p>
<p>以上就是代码实现的全部内容。</p>
<p><strong>小结</strong></p>
<ul>
<li>非加权图查找最短路径使用广度优先搜索；加权图中查找最短路径使用狄克斯特拉算法；</li>
<li>仅当权重为正时，狄克斯特拉算法才管用；图中含负权边时，使用贝尔曼-福德算法。</li>
</ul>
</div></article><div id="uyan_frame"></div><style>div#uyan_frame{
    margin-top:120px;
}</style><script src="http://v2.uyan.cc/code/uyan.js?uid=2129331"></script></div></main><footer><div class="paginator"><a href="/2019/02/15/rxjs-basic/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://coolseaman.github.io">Coolseaman</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>