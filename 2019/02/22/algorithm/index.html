<!DOCTYPE html><html lang="Zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script>(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4528ef8fec41aa4331cbdf867fe84204";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
})();
</script><title> 基础算法 · HY</title><meta name="description" content="基础算法 - Coolseaman"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://coolseaman.github.io/atom.xml" title="HY"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/coolseaman" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">基础算法</h1><div class="post-info">2019年2月22日</div><div class="post-content"><blockquote>
<p>最近打算学习一些算法，这里先对一些基础算法只是进行重温，对算法的知识点进行一些总结，毕竟有文字输出效果会更好。</p>
</blockquote>
<a id="more"></a>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归是一种非常优雅的解决问题的方式。它可以把复杂的问题逐步分解成简单的问题，逐步得到结果。<br>递归就是在函数中，满足递归条件，就调用函数自身，直到满足基线条件，递归返回。<br>每个递归函数都有两部分：</p>
<ul>
<li>基线条件：函数不再调用自己，避免形成无限循环。</li>
<li>递归条件：函数调用自己。</li>
</ul>
<p><strong>栈</strong><br>栈是计算机中一种非常常见的数据结构，可以进行数据的压入（插入）和弹出（删除并读取）。</p>
<p><strong>调用栈</strong><br>当函数调用时，计算机首先会为该函数调用分配一块内存，存储函数调用设计的所有变量值。当函数内部调用其他函数时，计算机就会为内部调用函数也分配一块内存，第二块内存位于第一块内存的上面，当函数调用返回，第二块内存就会从栈顶弹出。这就被称为调用栈。</p>
<p><strong>递归调用栈</strong><br>递归调用栈中包含所有未完成的函数调用。在递归中，在最终返回结果前，每个函数都还未完成，所以栈中会存储每个调用函数的信息，每个函数调用都要占用一定的内存。所以如果栈很高，就会占用非常多的内存资源。解决方法如下：</p>
<ul>
<li>重新编写代码，使用循环。</li>
<li>使用尾递归，这个貌似比较高级，待深究。</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>这里要用到一种分而治之的思想（divide and conquer, D&amp;C），即递归式问题解决方法。</p>
<p><strong>D&amp;C原理</strong></p>
<p>D&amp;C的工作原理：</p>
<ul>
<li>找出简单的基线条件；</li>
<li>确定如何缩小问题的规模，使其符合基线条件。</li>
</ul>
<p>这里有一个好玩的问题：</p>
<blockquote>
<p>假设你是一个农场主，有一块168*64的土地。<br>现在要你均匀分成正方形土地，且分的方块要尽可能大，你会怎样分？</p>
</blockquote>
<p>这里涉及到一个欧几里得算法的问题：又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。</p>
<p>我们可以先从这块地中划出两个最大的方块，然后对剩下的一小块地再次划出最大的方块，就这样递归，直到没有剩下地块为止。这样我们就使用的递归的方式来解决问题。</p>
<p><strong>快速排序</strong></p>
<p>工作原理：</p>
<ul>
<li>从数组中选择一个元素，这个元素成为基准值（pivot）；</li>
<li>找出比基准值小的元素以及比基准值大的元素，这被称为分区。分区后得到一个由所有小于基准值的数组成的子数组，一个由所有大于基准值的数组成的子数组，两个子数组是无序的；</li>
<li>然后对两个子数组进行快速排序。</li>
</ul>
<p>下面是快速排序的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def quicksort(array):</span><br><span class="line">    if len(array) &lt; 2:</span><br><span class="line">        return array</span><br><span class="line">    else:</span><br><span class="line">        pivot &#x3D; array[0]</span><br><span class="line">        less &#x3D; [i for i in array[1:] if i &lt;&#x3D; pivot]</span><br><span class="line">        greater &#x3D; [i for i in array[1:] if i &gt; pivot]</span><br><span class="line">        </span><br><span class="line">        return quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line">    </span><br><span class="line">print quicksort([10,5,2,3])</span><br></pre></td></tr></table></figure>
<p>时间复杂度<br>快速排序的性能高度依赖你选择的基准值。</p>
<ul>
<li>最糟情况：始终选择第一个值作为基准值，则调用栈的高度为n；</li>
<li>最佳情况：始终将中间值作为基准值，则调用栈的高度为log n。</li>
</ul>
<p>因为每层栈需要的时间为O(n)，所以时间复杂度方面：</p>
<ul>
<li>最佳情况：O(n) * O(log n) = O(n log n)</li>
<li>最糟情况：O(n) * O(n) = O(n2)</li>
</ul>
<p>最佳情况也是平均情况，只要每次都随机选择一个数组元素作为基准值，快速排序的平均运行时间将为O(n log n)。快速排序是最快的排序算法质疑，也是D&amp;C典范。</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表我们非常熟悉，在Python中就是字典，在JavaScript中就是对象，等。每一种语言中都有自己对于散列表的实现。这里简单总结一下散列表的实现原理。</p>
<p>散列表平均情况下的时间复杂度是个常量：O(1)</p>
<p><strong>实现原理</strong>：<br>    将输入通过散列函数输出一个数组的索引，在数组的该索引位置上存储一个值，这样就可以快速得出我们想要的结果。</p>
<p><strong>避免冲突</strong>：<br>不够理想的散列函数可能会将不同的键映射到数组的同一个位置，这样就需要在这个位置上存储一个链表，就会导致性能下降。</p>
<p>要提升散列表的性能，需要：</p>
<ul>
<li>较低的装填因子；</li>
<li>良好的散列函数。</li>
</ul>
<p>装填因子就是 <code>散列表包含的元素数/数组位置总数</code>。所以装填因子越小，冲突的可能性就越小，装填因子过大，我们可以调整数组长度，通常将数组增加一倍。一个不错的经验规则是：一旦装填因子大于0.7，就调整散列表的长度。</p>
<p>良好的散列函数可以让数组中的值呈均匀分布。</p>
<h2 id="广度优先搜索（宽度优先搜索）"><a href="#广度优先搜索（宽度优先搜索）" class="headerlink" title="广度优先搜索（宽度优先搜索）"></a>广度优先搜索（宽度优先搜索）</h2><p><strong>什么是图？</strong><br>图由节点和边组成，一个节点可能和众多节点相连接，这些节点称为邻居。</p>
<p>广度优先搜索是一种用于图的查找算法，帮助回答两个问题：</p>
<ul>
<li>从节点A出发，有前往节点B的路径吗？</li>
<li>从节点A出发，前往节点B的哪条路径最短？</li>
</ul>
<p>广度优先搜索的基本思路就是现在一级节点中搜索，如果找到目标，则完成，如果没有找到目标，继续在二级节点中搜索，依次是三级、四级…直到返回搜索结果。</p>
<p>在检查的过程中要按照添加顺序进行，所以我们要用到队列。队列是一种先进先出（FIFO）的数据结构，而栈是一种后进先出（LIFO）的数据结构。</p>
<p>关于图的代码实现，我们可以使用散列表来实现，例如下图：<br><img src="../../../../img/%E5%9B%BE.png" alt="img"></p>
<p>我们可以用如下代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph &#x3D; &#123;&#125; </span><br><span class="line">graph[&quot;you&quot;] &#x3D; [&quot;alice&quot;, &quot;bob&quot;, &quot;claire&quot;] </span><br><span class="line">graph[&quot;bob&quot;] &#x3D; [&quot;anuj&quot;, &quot;peggy&quot;]</span><br><span class="line">graph[&quot;alice&quot;] &#x3D; [&quot;peggy&quot;]</span><br><span class="line">graph[&quot;claire&quot;] &#x3D; [&quot;thom&quot;, &quot;jonny&quot;] </span><br><span class="line">graph[&quot;anuj&quot;] &#x3D; [] </span><br><span class="line">graph[&quot;peggy&quot;] &#x3D; [] </span><br><span class="line">graph[&quot;thom&quot;] &#x3D; [] </span><br><span class="line">graph[&quot;jonny&quot;] &#x3D; []</span><br></pre></td></tr></table></figure></p>
<p>算法实现原理：<br><img src="../../../../img/%E5%8E%9F%E7%90%86.png" alt="img"></p>
<p>算法代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line">def search(name):</span><br><span class="line">    search_queue &#x3D; deque()</span><br><span class="line">    search_queue +&#x3D; graph[name]</span><br><span class="line">    searched &#x3D; [] &#x2F;&#x2F;用于记录检查过的人</span><br><span class="line">    </span><br><span class="line">    while search_queue:</span><br><span class="line">        person &#x3D; search_queue.popleft()</span><br><span class="line">        if person not in searched:</span><br><span class="line">            if person_is_seller(person):</span><br><span class="line">                print person + &#39;is seller&#39;</span><br><span class="line">                return True</span><br><span class="line">            else: </span><br><span class="line">                search_queue +&#x3D; graph[person]</span><br><span class="line">        searched.append(person)</span><br><span class="line">        </span><br><span class="line">    return False</span><br><span class="line"></span><br><span class="line">def person_is_seller(name):</span><br><span class="line">    &#x2F;&#x2F;随意定义一个判断函数</span><br><span class="line">    return name[-1] &#x3D;&#x3D; &#39;m&#39;</span><br><span class="line">    </span><br><span class="line">search(&#39;you&#39;)</span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong></p>
<ul>
<li>面对寻找最短路径的问题，可以先用图来建立模型，再使用广度优先搜索来解决问题。</li>
<li>有向图中的边有箭头，箭头的方向指定了关系的方向。</li>
<li>无向图中的边没有箭头，其中的关系是双向的。</li>
<li>你需要按照加入顺序进行检查，否则找到的可能就不是最短路径，因此搜索列表必须是队列。</li>
<li>对于检查过的人务必不要再去检查，否则可能导致无限循环，例如一个无向图。</li>
</ul>
<h2 id="狄克斯特拉算法（Dijkstra）"><a href="#狄克斯特拉算法（Dijkstra）" class="headerlink" title="狄克斯特拉算法（Dijkstra）"></a>狄克斯特拉算法（Dijkstra）</h2><p>前一章中使用广度优先搜索来查找两点之间的最短路径，那是的最短路径的意思是段数最少。在狄克斯特拉算法中，给每段都分配了数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。</p>
<blockquote>
<p>狄克斯特拉算法只适用于有向无环图。<br>狄克斯特拉算法不能用于包括负权边的图。</p>
</blockquote>
<p><strong>实现</strong><br>我们以下图中的例子来进行实现：<br><img src="../../../../img/dijkstra.png" alt="img"></p>
<p>首先，我们需要定义三个散列表来记录图的相关信息。<br>graph:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; graph用来记录图的信息，包括节点的邻居和前往邻居的开销</span><br><span class="line">graph &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">graph[&#39;start&#39;] &#x3D; &#123;&#125;</span><br><span class="line">graph[&#39;start&#39;][&#39;a&#39;] &#x3D; 6</span><br><span class="line">graph[&#39;start&#39;][&#39;b&#39;] &#x3D; 2</span><br><span class="line"></span><br><span class="line">graph[&#39;a&#39;] &#x3D; &#123;&#125;</span><br><span class="line">graph[&#39;a&#39;][&#39;fin&#39;] &#x3D; 1</span><br><span class="line"></span><br><span class="line">graph[&#39;b&#39;] &#x3D; &#123;&#125;</span><br><span class="line">graph[&#39;b&#39;][&#39;a&#39;] &#x3D; 3</span><br><span class="line">graph[&#39;b&#39;][&#39;fin&#39;] &#x3D; 5</span><br><span class="line"></span><br><span class="line">graph[&#39;fin&#39;] &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure><br>costs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;costs用于存储每个节点的开销</span><br><span class="line">infinity &#x3D; float(&#39;inf&#39;)</span><br><span class="line">costs &#x3D; &#123;&#125;</span><br><span class="line">costs[&#39;a&#39;] &#x3D; 6</span><br><span class="line">costs[&#39;b&#39;] &#x3D; 2</span><br><span class="line">costs[&#39;fin&#39;] &#x3D; infinity</span><br></pre></td></tr></table></figure><br>parents:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; parents用于存储父节点</span><br><span class="line">parents &#x3D; &#123;&#125;</span><br><span class="line">parents[&#39;a&#39;] &#x3D; &#39;start&#39;</span><br><span class="line">parents[&#39;b&#39;] &#x3D; &#39;start&#39;</span><br><span class="line">parents[&#39;fin&#39;] &#x3D; None</span><br></pre></td></tr></table></figure><br>还需要一个数组用于存储已处理过的节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processed &#x3D; []</span><br></pre></td></tr></table></figure><br>完成了各种数据结构的创建，接下来我们开始算法。<br><img src="../../../../img/dijkstra1.png" alt="img"><br>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 未处理的节点中找到开销最小的节点</span><br><span class="line">node &#x3D; find_lowest_cost_node(costs)</span><br><span class="line"></span><br><span class="line">while node is not None:</span><br><span class="line">    cost &#x3D; costs[node]</span><br><span class="line">    neighbors &#x3D; graph[node]</span><br><span class="line">    for n in neighbors.keys():</span><br><span class="line">        new_cost &#x3D; cost + neighbors[n]</span><br><span class="line">        if costs[n] &gt; new_cost:</span><br><span class="line">            costs[n] &#x3D; new_cost</span><br><span class="line">            parents[n] &#x3D; node</span><br><span class="line">        </span><br><span class="line">    processed.append(node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def find_lowest_cost_node(costs): </span><br><span class="line">    lowest_cost &#x3D; float(&#39;inf&#39;)</span><br><span class="line">    lowest_cost_node &#x3D; None</span><br><span class="line">    </span><br><span class="line">    for node in costs:</span><br><span class="line">        cost &#x3D; cost[node]</span><br><span class="line">        if cost &lt; lowest_cost and node not in processed:</span><br><span class="line">            lowest_cost &#x3D; cost</span><br><span class="line">            lowest_cost_node &#x3D; node </span><br><span class="line">    </span><br><span class="line">    return lowest_cost_node</span><br></pre></td></tr></table></figure></p>
<p>以上就是代码实现的全部内容。</p>
<p><strong>小结</strong></p>
<ul>
<li>非加权图查找最短路径使用广度优先搜索；加权图中查找最短路径使用狄克斯特拉算法；</li>
<li>仅当权重为正时，狄克斯特拉算法才管用；图中含负权边时，使用贝尔曼-福德算法。</li>
</ul>
<h2 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h2><p>贪婪算法是指，在对问题求解时，总是做出在当前看来是最好的选择。就是说，你每步都选择局部最优解，不从整体最优上加以考虑。贪婪算法不能得出最优解，但非常接近最优解。</p>
<p><strong>集合覆盖问题</strong><br>举个例子：<br>你要办一个广播节目，让全美50个州都能收听得到。为此，你需要决定在哪些广播台播出。每个广播台都需要支付费用，因此你力图在尽可能少的广播台播出。</p>
<p>算法：</p>
<ol>
<li>选出这样一个广播台，即它覆盖了最多的未覆盖州。即使已覆盖一些州，也没关系；</li>
<li>重复上一步，知道覆盖了所有州。</li>
</ol>
<p>这就是一种近似算法，因为获得精确解需要的时间太长。判断近似算法优劣的标准如下：</p>
<ul>
<li>速度有多快；</li>
<li>得到的近似解与最优解的接近程度。</li>
</ul>
<p><strong>代码实现</strong><br>出于简化考虑，智力要覆盖州、广播台没有那么多。</p>
<p>构建原始数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个集合，包含要覆盖的州</span><br><span class="line">states_needed &#x3D; set([&#39;mt&#39;, &#39;wa&#39;, &#39;or&#39;, &#39;id&#39;, &#39;nv&#39;]) </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 键为广播站名，值为广播站覆盖的州</span><br><span class="line">stations &#x3D; &#123;&#125;</span><br><span class="line">stations[&#39;kone&#39;] &#x3D; set([&#39;id&#39;, &#39;nv&#39;])</span><br><span class="line">stations[&#39;ktwo&#39;] &#x3D; set([&#39;wa&#39;, &#39;id&#39;, &#39;mt&#39;])</span><br><span class="line">stations[&#39;kthree&#39;] &#x3D; set([&#39;or&#39;, &#39;nv&#39;])</span><br><span class="line">stations[&#39;kfour&#39;] &#x3D; set([&#39;nv&#39;])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 存储最终选择的广播台</span><br><span class="line">final_stations &#x3D; set()</span><br></pre></td></tr></table></figure></p>
<p>逻辑代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while states_needed: &#x2F;&#x2F; 只要需要覆盖的州不为空，一直循环</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 每一次循环都是通过遍历所有广播台，找出覆盖剩余需要覆盖州最多的电台</span><br><span class="line">    best_station &#x3D; None &#x2F;&#x2F; 覆盖州最多的广播台</span><br><span class="line">    states_covered &#x3D; set()  &#x2F;&#x2F; 覆盖州的集合</span><br><span class="line">    </span><br><span class="line">    for station, states in stations.items():    &#x2F;&#x2F; 遍历所有广播台</span><br><span class="line">        covered &#x3D; states_needed &amp; states    &#x2F;&#x2F;  当前广播台覆盖州和需要覆盖州的交集</span><br><span class="line">        if len(covered) &gt; len(states_covered): &#x2F;&#x2F; 判断当前广播台覆盖的州是否是最多的</span><br><span class="line">            states_covered &#x3D; covered    </span><br><span class="line">            best_station &#x3D; station</span><br><span class="line">    </span><br><span class="line">    states_needed -&#x3D; states_covered &#x2F;&#x2F; 需要覆盖州与当前广播台所覆盖的州取差集</span><br><span class="line">    final_stations.add(best_station)    &#x2F;&#x2F; 添加当前广播台</span><br></pre></td></tr></table></figure></p>
<p><strong>NP完全问题</strong><br>NP完全问题定义为，以难解著称的问题，根本不可能编写出可快速解决这些问题的算法。</p>
<p>例如，要找出A、B两点之间的最短路径是很容易得出，但如果要找出指定几个点的最短路径，就是商旅问题，这就是一个NP完全问题。<br>一般判断一个问题是否为NP问题依据：</p>
<ul>
<li>元素较少时算法运算速度非常快，但随着元素数量的增加，速度会变得非常慢；</li>
<li>涉及“所有组合”的问题通常是NP完全问题；</li>
<li>不能将问题分成小问题，必须考虑各种可能的情况；</li>
<li>问题涉及序列且难以解决，如商旅问题；</li>
<li>问题涉及集合且难以解决，如广播台集合。</li>
</ul>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="K最近邻算法"><a href="#K最近邻算法" class="headerlink" title="K最近邻算法"></a>K最近邻算法</h2><p>K-nearest neighbor，简称KNN算法。堪称你进入机器学习领域的领路人。</p>
<p>K最近邻算法可以用于创建分类系统，通过特征值的计算，找出最接近的邻居数据，就可归为相同类别。</p>
<p>通过这样的算法，可以构建一个推荐系统。</p>
<p>挑选正确的特征值对于算法的准确性非常重要。</p>
<p>朴素贝叶斯分类器应用领域与KNN算法相似，通过计算概率来做预测。</p>
<p><strong>小结</strong></p>
<ul>
<li>KNN算法用于分类和回归，需要考虑最近的邻居；</li>
<li>分类就是编组；回归就是预测结果；</li>
<li>特征抽取意味着将物品转化为一系列可比较的数字；</li>
<li>能否挑选合适的特征事关KNN算法的成败。</li>
</ul>
<h2 id="更多算法介绍"><a href="#更多算法介绍" class="headerlink" title="更多算法介绍"></a>更多算法介绍</h2><p><strong>树</strong></p>
<p>二叉树对于其中的每一个节点，左子节点的值都比它小，右子节点的值都比它大。</p>
<p>二叉树查找节点时，平均运行时间O(log n)，最糟糕情况下所需时间O(n)。二分法最糟糕情况下的时间只有O(log n)，可能会认为二分法比二叉树更佳。然而，二叉树插入和删除操作速度更快，平均运行时间都为O(log n)。</p>
<p>二叉树缺点就是不能随机访问。</p>
<blockquote>
<p>另外，还有B树、红黑树、堆、伸展树。</p>
</blockquote>
<p><strong>反向索引</strong></p>
<p>主要用于搜索引擎， 通过构建一个散列表，键值为关键词，值为关键词对应的页面，将单词映射到包含它的页面。</p>
<p><strong>傅里叶变换</strong></p>
<p><strong>并行算法</strong></p>
<p>用于改善性能和拓展性。</p>
<p><strong>MapReduce</strong></p>
<p>一种流行的分布式算法，可以通过开元工具Apache Hadoop来使用它。当需要几个内核时，可以使用并行算法，但当需要使用上百个内核时，就需要在多态计算机上运行。<br>基于两个简单的理念：映射（map）函数和归并（reduce）函数。</p>
<p><strong>布隆过滤器和HyperLogLog</strong></p>
<p>这两种算法都属于概率性算法，不能保证结果百分百准确，但八九不离十，对于海量数据非常有用，减少存储空间的占用。</p>
<p><strong>SHA算法</strong></p>
<p>安全散列算法（secure hash algorithm）函数。给定一个字符串，SHA返回其散列值。</p>
<p>可以根据生成的散列值，对判断两个文件是否相同。</p>
<p>对密码进行加密。在存储用户密码时，之存储密码的SHA散列值，用户输入密码后，计算其SHA散列值，将结果通数据库中的散列值进行比较。这样即使密码泄露，也不会泄露原始密码。因为SHA算法是单向的，根据散列值无法推断出原始字符串。</p>
<p><strong>局部敏感的散列算法</strong></p>
<p>SHA算法的一个重要特征就是局部不敏感。如果你修改了字符串中的一个字符，计算的散列值截然不同。</p>
<p>但一些情况下我们希望散列函数是局部敏感的，可以使用Simhash。对字符串做细微修改，生成的散列值只存在细微的差别，这样可以判断字符串的相似程度。</p>
<p>场景：</p>
<ul>
<li>判断网页是否已搜索；</li>
<li>论文查重。</li>
</ul>
<p><strong>Diffie-Hellman秘钥交换</strong></p>
<p>就是我们熟知的公私钥加密算法，它的替代者RSA也一样广泛使用。</p>
<p><strong>线性规划</strong></p>
<blockquote>
<p>结束语：<br>整篇文章主要是我对于《图解算法》这本书的阅读总结，后续会更深入地了解更多算法。</p>
</blockquote>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"66b3bec2ed166012b227","clientSecret":"aa06be78857099bba47974a90299ffa0607acea3","repo":"coolseaman.github.io","owner":"coolseaman","admin":"coolseaman","distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script></div></article><div id="uyan_frame"></div><style>div#uyan_frame{
    margin-top:120px;
}</style><script src="http://v2.uyan.cc/code/uyan.js?uid=2129331"></script></div></main><footer><div class="paginator"><a href="/2019/02/15/rxjs-basic/" class="next">NEXT</a></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><div id="gitalk-container"></div><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>gitalk = new Gitalk({
    clientID: '66b3bec2ed166012b227',
    clientSecret: 'aa06be78857099bba47974a90299ffa0607acea3',
    repo: 'coolseaman.github.io',
    owner: '',
    admin: 'coolseaman',
    id: window.location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
});
gitalk.render('gitalk-container');</script><div class="copyright"><p>© 2015 - 2020 <a href="https://coolseaman.github.io">Coolseaman</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>