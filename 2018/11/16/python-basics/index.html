<!DOCTYPE html><html lang="Zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><script>(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4528ef8fec41aa4331cbdf867fe84204";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
})();
</script><title> Python基础小结 · HY</title><meta name="description" content="Python基础小结 - Coolseaman"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://coolseaman.github.io/atom.xml" title="HY"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/coolseaman" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Python基础小结</h1><div class="post-info">2018年11月16日</div><div class="post-content"><blockquote>
<p>最近看了《Python编程：从入门到实践》一书，强烈推荐作为Python的入门书籍，非常清晰易懂。之前已经有了Python开发的经验，所以就把书里关于Python的新发现总结一下。</p>
</blockquote>
<a id="more"></a>
<h4 id="在列表中添加元素"><a href="#在列表中添加元素" class="headerlink" title="在列表中添加元素"></a>在列表中添加元素</h4><ul>
<li><p>append()<br>  列表最后追加元素。</p>
</li>
<li><p>insert()<br>  在列表的任何位置添加新元素。需要指定新元素的索引和值。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles &#x3D; [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]</span><br><span class="line">motorcycles.insert(0, &#39;ducati&#39;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="在列表中删除元素"><a href="#在列表中删除元素" class="headerlink" title="在列表中删除元素"></a>在列表中删除元素</h4><ul>
<li><p>del<br>  如果知道要删除元素在列表中的位置，可以使用del语句。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles &#x3D; [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]</span><br><span class="line">del motorcycles[0]</span><br></pre></td></tr></table></figure></li>
<li>pop()<br>  pop()可删除列表末尾的元素，<strong>并可以让你使用该元素</strong>。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles &#x3D; [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]</span><br><span class="line">popped_motorcycle &#x3D; motorcycles.pop()</span><br></pre></td></tr></table></figure>
  pop()还可以删除列表中任何位置的元素，只需在括号中指定要删除元素的索引即可。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles &#x3D; [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]</span><br><span class="line">motorcycles.pop(0)</span><br></pre></td></tr></table></figure></li>
<li>remove()<br>  当你只知道要删除元素的值，不知道要删除元素所处的位置时，可以使用remove()方法。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles &#x3D; [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]</span><br><span class="line">motorcycles.remove(&#39;ducati&#39;)</span><br></pre></td></tr></table></figure>
  <strong>注意：remove()方法只能删除第一个指定的值，如果要删除的值在列表中出现多次，就需要使用循环判断是否删除所有这样的值</strong></li>
</ul>
<h4 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h4><ul>
<li><p>sort()<br>  sort()方法会永久性地修改列表元素的排列顺序，默认按照字母顺序进行排序。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cars &#x3D; [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;]</span><br><span class="line">cars.sort()</span><br></pre></td></tr></table></figure>
<p>  将列表按照字母顺序相反的顺序排序。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cars &#x3D; [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;]</span><br><span class="line">cars.sort(reverse&#x3D;True)</span><br></pre></td></tr></table></figure></li>
<li><p>sorted()<br>  要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可以使用sorted()方法。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cars &#x3D; [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;]</span><br><span class="line">sorted(cars)</span><br></pre></td></tr></table></figure>
<p>  要按照字母顺序相反顺序显示列表时，可向sorted()函数传递参数reverse=True。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cars &#x3D; [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;]</span><br><span class="line">sorted(cars, reverse&#x3D;True)</span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse()<br>  要反转列表元素的排列顺序，可使用方法reverse()。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cars &#x3D; [&#39;bmw&#39;, &#39;audi&#39;, &#39;toyota&#39;, &#39;subaru&#39;]</span><br><span class="line">cars.reverse()</span><br></pre></td></tr></table></figure>
<p>  <strong>注意：reverse()方法不是按照与字母顺序相反的顺序排列列表元素，只是反转列表元素的排列顺序。</strong><br>  方法reverse()会永久性地改变列表元素的排列顺序，但可以随时恢复原来的排列顺序，只需再调用一次reverse()即可。</p>
</li>
</ul>
<h4 id="列表切片"><a href="#列表切片" class="headerlink" title="列表切片"></a>列表切片</h4><p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引。<br>例如要输出列表的前三个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players &#x3D; [&#39;charles&#39;, &#39;martina&#39;, &#39;michael&#39;, &#39;florence&#39;, &#39;eli&#39;]</span><br><span class="line">print(players[0:3])</span><br></pre></td></tr></table></figure>
<p>如果你没指定第一个索引，Python将自动从列表第一个元素开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players &#x3D; [&#39;charles&#39;, &#39;martina&#39;, &#39;michael&#39;, &#39;florence&#39;, &#39;eli&#39;]</span><br><span class="line">print(players[:4])</span><br></pre></td></tr></table></figure><br>要让切片终止于列表末尾，也可使用类似语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players &#x3D; [&#39;charles&#39;, &#39;martina&#39;, &#39;michael&#39;, &#39;florence&#39;, &#39;eli&#39;]</span><br><span class="line">print(players[2:])</span><br></pre></td></tr></table></figure><br>负数索引返回离列表末尾相应距离的元素，因此你可以输出列表末尾的任何切片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players &#x3D; [&#39;charles&#39;, &#39;martina&#39;, &#39;michael&#39;, &#39;florence&#39;, &#39;eli&#39;]</span><br><span class="line">print(players[-3:])</span><br></pre></td></tr></table></figure><br>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]）。这样可以为列表创建一个副本，即便修改副本也不会改变原列表。</p>
<h4 id="数值列表"><a href="#数值列表" class="headerlink" title="数值列表"></a>数值列表</h4><ul>
<li><p>range()<br>  range()函数可以生成一系列数字。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for value in range(1, 5):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure>
<p>  输出：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>  函数range()从你指定的第一个值开始数，在到达你指定的第二个值后停止，所以输出不包含第二个值。<br>  使用range()函数可以指定步长，例如打印1~10内的含的偶数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">even_numbers &#x3D; list(range(2, 11, 2))</span><br></pre></td></tr></table></figure>
<p>  用range()创建数字列表</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; list(range(1, 6))</span><br></pre></td></tr></table></figure></li>
<li>对数字列表执行简单统计计算  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">digits &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span><br><span class="line">min(digits)</span><br><span class="line">max(digits)</span><br><span class="line">sum(digits)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>Python将不能修改的值称为不可变的，而不可变得列表被称为元组。元组使用圆括号来标识。</p>
<h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>函数input()可以让程序暂停运行，等待用户输入一些文本，获取用户输入后，Python将其存储在一个变量中，以方便你使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message &#x3D; input(&quot;Tell me something, and I will repeat it back to you: &quot;)</span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul>
<li><p>__init__(self，[args])方法<br>当创建类的实例时，Python都会自动运行此方法。self形参必不可少哦，还必须位于其他形参前面。</p>
<p>  <strong>为什么必须包含形参self？</strong><br>  因为python创建实例时，将自动传入形参self，每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</p>
</li>
<li><p>类的继承<br>这里的示例中，ElectricCar类继承了Car类的方法和属性：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Car():</span><br><span class="line">    def __init__(self, model, year):</span><br><span class="line">        self.model &#x3D; model</span><br><span class="line">        self.year &#x3D; year</span><br><span class="line"></span><br><span class="line">class ElectricCar(Car):</span><br><span class="line">    def __init__(self, model, year):</span><br><span class="line">        super().__init__(model, year)</span><br></pre></td></tr></table></figure>
<p>  创建子类时，父类必须包含在当前文件中，且位于子类前面。<br>  <code>super()</code>是一个特殊函数，让子类和父类联系起来，这行代码会执行父类的<code>__init__()</code>方法，让子类包含父类的所有属性，父类也称超类，super由此而来。</p>
</li>
<li><p>重写父类方法<br>  对于父类的方法，只要它不符合子类的需要，都可以进行重写。可以在子类中定义一个这样的方法，让它与要重写的父类方法同名即可，Python将不关注父类中的方法，只关注子类中重写的方法。 </p>
</li>
</ul>
<h4 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h4><ul>
<li><p>导入整个模块<br>  只需编写一条import语句并在其中指定模块名，就可以在程序中使用该模块的所有函数，可以使用下面的语法来使用其中的任何一个函数。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_name.function_name()</span><br></pre></td></tr></table></figure></li>
<li><p>导入特定的函数<br>  导入方法如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from module_name import function_name</span><br><span class="line"></span><br><span class="line"># 导入多个函数</span><br><span class="line">from module_name import function_0, function_1, function_2</span><br></pre></td></tr></table></figure>
<p>  因为已经显式地导入了函数，因此调用它时只需指定其名称。</p>
</li>
<li><p>用as给函数指定别名</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from module_name import function_name as fn   </span><br><span class="line">fn()</span><br></pre></td></tr></table></figure></li>
<li>用as给模块指定别名  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import module_name as mn</span><br><span class="line">mn.fun1()</span><br><span class="line">mn.fun2()</span><br></pre></td></tr></table></figure></li>
<li>导入模块中所有函数<br>  使用星号（*）运算符可以让Python导入模块中的所有函数。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from module_name import *</span><br><span class="line">fun1()</span><br><span class="line">fun2()</span><br></pre></td></tr></table></figure>
  星号将模块中的每个函数都复制到这个程序文件中，所以可以通过名称调用每个函数。然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法：如果模块中有函数的名称与你项目中使用的名称相同，可能导致意想不到的结果。Python可能遇到多个名称相同的函数或变量，进而覆盖函数，而不是分别导入所有的函数。</li>
</ul>
<h4 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h4><ul>
<li><p>读取整个文件内容<br>  <code>pi_digits.txt</code>使我们要读取的文件，脚本文件<code>read_file.py</code>内容如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&#39;pi_digits.txt&#39;) as file_object:</span><br><span class="line">    content &#x3D; file_object.read()</span><br><span class="line">    print(content)</span><br></pre></td></tr></table></figure>
<p>  <code>open()</code>函数参数为要打开文件的文件名，返回一个文件对象，并存储在一个变量<code>file_object</code>中。</p>
<p>  关键字<code>with</code>在不再需要访问文件后将其关闭。你只需要打开文件，在需要时使用文件，Python会在适合的时候自动关闭它。当然，你也可以使用<code>close()</code>关闭来关闭文件，但是一旦程序出现bug，导致<code>close()</code>未执行，文件将不会执行，有可能导致文件数据丢失或受损。如果过早调用<code>close()</code>，你会发现需要使用文件时，文件已关闭，便会导致错误发生。</p>
<p>  对文件对象调用<code>read()</code>方法，便可以读取文件内容。<br>  打印出的结果会多出一个空行，这是为什么呢？<code>read()</code>到达文件末尾时返回一个空字符串，而将这个空字符串显示出来就是一个空行，所以要删除多出来的空行，可以如下解决：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(content.rstrip())</span><br></pre></td></tr></table></figure></li>
<li><p>读取文件各行内容</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    with open(filename) as file_object:</span><br><span class="line">        lines &#x3D; file_object.readlines()</span><br><span class="line">        </span><br><span class="line">    for line in lines:</span><br><span class="line">        print(line.rstrip())</span><br><span class="line">    &#96;&#96;&#96;    </span><br><span class="line">* 写入文件</span><br></pre></td></tr></table></figure>
<p>  filename = ‘programming.txt’<br>  with open(filename, ‘w’) as file_object:</p>
<pre><code>file_object.write(&quot;I love programming.\n&quot;)
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    第二个实参‘w’告诉Python，我们要以写入模式打开这个文件。打开文件时，可指定读取模式（&#39;r&#39;），写入模式（&#39;w&#39;），附件模式（&#39;a&#39;），或者能够读取和写入文件的模式（&#39;r+&#39;）。如果省略了模式实参，Python将以默认的只读模式打开文件。如果你要写入的文件不存在，函数open()将自动创建它。然后以写入模式打开文件时要小心，因为如果指定文件已存在，Python将在返回文件对象前清空该文件。</span><br><span class="line">    </span><br><span class="line">* 存储数据</span><br><span class="line">    有时关闭程序，也需要将数据进行存储。一种简单的方式是使用json来存储数据，模块json可以将Python数据结构转存到文件中，并在程序运行时加载文件中的数据。</span><br><span class="line">    &#96;json.dump()&#96;、&#96;json.load()&#96;用于进行json的数据存储和读取。</span><br></pre></td></tr></table></figure>
<p>  import json</p>
<p>  numbers = [1, 2, 3, 4]<br>  filename = ‘numbers.json’<br>  with open(filename, ‘w’) as f_obj:</p>
<pre><code>json.dump(numbers, f_obj)
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数&#96;dump()&#96;接受两个参数，要存储的数据以及用于存储数据的文件对象。</span><br></pre></td></tr></table></figure>
<p>  import json</p>
<p>  filename = numbers.json<br>  with open(filename) as f_obj:</p>
<pre><code>numbers = json.load(f_obj)
</code></pre><p>  print(numbers)<br>  <code>`</code></p>
</li>
</ul>
<h4 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h4><ul>
<li>setup()函数<br>  在对一个类编写测试用例时，为了只创建一次实例，并在每个测试方法中使用实例，我们可以使用<code>setup()</code>函数创建实例。在TestCase类中包含<code>setup()</code>方法，Python将先运行它，在运行各个以<code>test_</code>打头的函数，这样在你编写的每一个测试方法中都可以使用在方法<code>setup()</code>中创建的对象了。</li>
</ul>
<blockquote>
<p>本篇内容随时更新。。。</p>
</blockquote>
</div></article><div id="uyan_frame"></div><style>div#uyan_frame{
    margin-top:120px;
}</style><script src="http://v2.uyan.cc/code/uyan.js?uid=2129331"></script></div></main><footer><div class="paginator"><a href="/2018/11/26/front-end-module/" class="prev">PREV</a><a href="/2018/03/22/webhook/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2020 <a href="https://coolseaman.github.io">Coolseaman</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>